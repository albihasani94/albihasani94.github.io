---
layout: post
title: "Helidon, child of Java EE and the Cloud"
date: 2020-06-07
permalink: helidon-mp.html
categories: [java, helidon]
tags: [java, helidon, cloud, graalvm, docker]
description: "What is Helidon? Turning to ethimology, Helidon comes from Greece and it means the swallow bird in English."
image: assets/images/swallow_noun.jpg
excerpt_separator: <!--more-->
---

What is Helidon? Turning to etymology, Helidon comes from Greece and it means the _swallow_ bird in English.

<!--more-->

According to the Cambridge Dictionary, [swallow](https://dictionary.cambridge.org/dictionary/english/swallow){:target="_blank"} is a small bird with pointed wings and a tail with two points that flies quickly and catches insects to eat as it flies. 

![helidon-bird](/assets/images/swallow_noun.jpg)

Oracle nailed it getting the coolest name for a tech framework. You’ve most likely seen this kind of bird at least once, and of course, it is dallëndyshe in Albanian.

Let’s head to the motivation behind this framework and the purpose it holds, as it takes flight.

Now as it is common with birds, there are many families. And Helidon comes in two shapes, Helidon SE and Helidon MP.

Helidon SE embraces the latest Java SE features: reactive streams, asynchronous and functional programming, and fluent-style APIs. At the same time, Helidon MP provides an implementation of the MicroProfile specification. This is the child of Java EE and the cloud.

Helidon SE seems to be the coolest of the siblings, but both look like a step in the right direction to me.

With this post, I am going to give a try to the Helidon MP. I am going to start with the Helidon v2, which requires Maven 3.6.1+ and JDK 11 or newer.

## Preparing the Ground

There is a proper way to start with it, by using a maven archetype.

```bash
mvn archetype:generate -DinteractiveMode=false \
    -DarchetypeGroupId=io.helidon.archetypes \
    -DarchetypeArtifactId=helidon-quickstart-mp \
    -DarchetypeVersion=2.0.0-RC1 \
    -DgroupId=com.albi \
    -DartifactId=helidon-mp \
    -Dpackage=com.albi.helidon.mp
```

By navigating to the project, we see that the directory has the following structure:

```bash
.
├── Dockerfile
├── Dockerfile.jlink
├── Dockerfile.native
├── README.md
├── app.yaml
├── pom.xml
└── src
    ├── main
    │   ├── java
    │   │   └── com
    │   │       └── albi
    │   │           └── helidon
    │   │               └── mp
    │   │                   ├── GreetResource.java
    │   │                   ├── GreetingProvider.java
    │   │                   ├── ReactiveService.java
    │   │                   └── package-info.java
    │   └── resources
    │       ├── META-INF
    │       │   ├── beans.xml
    │       │   └── microprofile-config.properties
    │       └── logging.properties
    └── test
        ├── java
        │   └── com
        │       └── albi
        │           └── helidon
        │               └── mp
        │                   └── MainTest.java
        └── resources
            └── META-INF
                └── microprofile-config.properties
```

That’s neat. And there is some code for us. We will look at it shortly.

We build the application:

```bash
mvn package
```

As the build tool fetches the dependencies, runs some tests, we will be set.

## Let's ~~run~~ fly

```bash
java -jar target/helidon-mp.jar
```

Well, that was.. like pretty fast. Let's see what we got here.

Either via curl or Postman (or [Insomnia](https://insomnia.rest/){:target="_blank"}):

```
curl -X GET http://localhost:8080/greet
```

The response is on point:

```
{
  "message": "Hello World!"
}
```

Try another one

```
curl -X GET http://localhost:8080/greet/Helidon
```

Response

```
{
  "message": "Hello Helidon!"
}
```

GET requests are easy. We all know what's tricky. PUT requests. Make the computer listen from your input.

```
curl -X PUT -H "Content-Type: application/json" -d \
  '{"greeting" : "Aloha"}' http://localhost:8080/greet/greeting
```

This request has no response body. It could return the updated greeting in my opinion.

Now we've changed the greeting. Let's greet someone cool, like [Stitch](https://en.wikipedia.org/wiki/Stitch_(Disney)){:target="_blank"}.

```
curl -X GET http://localhost:8080/greet/Stitch
```

Response

```
{
  "message": "Aloha Stitch!"
}
```

The way it works just of the box is impressive. No hand-written dependencies, no setup, and no application server!

Let's see what we had there to start with in more detail.

## Show me the code

The bits of application logic provided to us free of charge or any pain are in the following source files.

```bash
── mp
   ├── GreetResource.java
   ├── GreetingProvider.java
   └── ReactiveService.java
```

We're going to see the main picture without focusing too much on the methods.

First goes the GreetResource:

```java
@Path("/greet")
@RequestScoped
public class GreetResource {

    @Inject 
    GreetingProvider greetingProvider;

    @Path("/{name}")
    @GET
    @Produces(MediaType.APPLICATION_JSON)
    public JsonObject getMessage(@PathParam("name") String name) {
        return createResponse(name);
    }

    // add other paths and methods
```

This is a JAX-RS application. Java EE is dead. Long live Jakarta EE!

Then comes the GreetingProvider:

```java
@ApplicationScoped
public class GreetingProvider {
    private final AtomicReference<String> message = new AtomicReference<>();

    @Inject
    public GreetingProvider(@ConfigProperty(name = "app.greeting") String message) {
        this.message.set(message);
    }

    // getter and setter
}
```

This is a CDI bean. It acts as a provider for the GreetResource, in which it has been injected. The `@ConfigProperty` annotation injects an application property into the source code.
This feature is part of the [MicroProfile Configuration](https://www.tomitribe.com/blog/an-overview-of-microprofile-configuration/){:target="_blank"} API.

## Checking the gears

Taking a look for a minute at the `resources` folder reveals some configuration properties.

```bash
── resources
   ├── META-INF
   │   ├── beans.xml
   │   └── microprofile-config.properties
   └── logging.properties
```

The `beans.xml` belongs to the CDI specification and is used to enable CDI services. By default, annotated beans are considered for dependency injection.

```xml
bean-discovery-mode="annotated"
```

The `microprofile-config.properties` can hold application properties and microprofile server properties, e.g. port.

```properties
# Application properties. This is the default greeting
app.greeting=Hello

# Microprofile server properties
server.port=8080
```

And the logging configuration can be tuned in `logging.properties`, as the name suggests.

## Inspecting over the nest

If we take a look at the `target` directory, where our build is created, we're in for interesting stuff.

```bash
du -sh target/*
 28K	target/classes
  0B	target/generated-sources
  0B	target/generated-test-sources
 12K	target/helidon-mp.jar
 18M	target/libs
4.0K	target/maven-archiver
 16K	target/maven-status
 12K	target/surefire-reports
8.0K	target/test-classes
```

The `jar` where our application logic resides is only `12 KBytes`. That's crazy, even beyond java standards.

The actual reason for that is that application dependencies lie in the `libs` folder. This is a very intuitive decision. 

Build-wise, it allows docker builds to be faster by only doing a rebuild of your application rather than having to build runtime dependencies into the jar, hence the cloud-native part.

Secondly, but no less important, there is a clear separation between the business logic and the libraries, as it should be.

## Adding DataSource to the mix

Add dependencies.

```xml
<dependency>
    <groupId>com.h2database</groupId>
    <artifactId>h2</artifactId>
    <version>1.4.199</version>
    <scope>runtime</scope>
</dependency>
<dependency>
    <groupId>io.helidon.integrations.cdi</groupId>
    <artifactId>helidon-integrations-cdi-datasource-hikaricp</artifactId>
    <scope>runtime</scope>
</dependency>
```

Add db connection properties.

```properties
javax.sql.DataSource.test.dataSourceClassName=org.h2.jdbcx.JdbcDataSource
javax.sql.DataSource.test.dataSource.url=jdbc:h2:mem:test
javax.sql.DataSource.test.dataSource.user=sa
javax.sql.DataSource.test.dataSource.password=
```

Interacting with the db is straightforward.

```java
@Path("/ds")
@ApplicationScoped
public class DataSourceExample {
    @Inject
    @Named("test")
    private DataSource testDataSource;

    @GET
    @Path("tables")
    @Produces("text/plain")
    public String getTableNames() throws SQLException {
        StringBuilder sb = new StringBuilder();
        try (Connection connection = this.testDataSource.getConnection();
             PreparedStatement ps =
                     connection.prepareStatement(" SELECT TABLE_NAME"
                             + " FROM INFORMATION_SCHEMA.TABLES "
                             + "ORDER BY TABLE_NAME ASC");
             ResultSet rs = ps.executeQuery()) {
            while (rs.next()) {
                sb.append(rs.getString(1)).append("\n");
            }
        }
        return sb.toString();
    }
}
```

Reaching the endpoint.

```bash
curl -X GET http://localhost:8080/ds/tables
```

This will fetch and display table names for the information schema in H2 database.

```bash
CATALOGS
COLLATIONS
COLUMNS
...
USERS
VIEWS
```

## Adding persistence

I have added persistence to my demo application, but it is nothing more than this [post](https://medium.com/helidon/helidon-and-jpa-da20492f5395){:target="_blank"} I came across. I recommend reading it if you want to take a look at JPA integration.

## openapi (just a couple of lines)

## Maybe add dockah? (fo suah)

## jlink? (yep)

## Tell GraalVM Story (definitely)

## Conclusion

…

On a personal note, it feels refreshing to get to write after such a long time. Since the last time I did Earth has seen a global disease outbreak, the quarantine, UFOs were confirmed by the US government, and the protests in USA. We have to come together as humans, be kind, and this too shall pass.
